# -*- coding: utf-8 -*-
"""lppls.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mYyxyAAGJROrkEe4lXFI95pW5khi5xYL
"""

import datetime
import itertools
from matplotlib import pyplot as plt
import numpy as np
import pandas as pd
import random
from scipy.optimize import minimize
from scipy import linalg
import seaborn as sns
# data from yahoo finance
data = pd.read_csv("data/sp500_10.2013-10.2018.csv", index_col="Date")

# data = data.iloc[::-1]
# data = data.head(250)

# organize DataSeries
date = data.index
tLen = len(data)
time = np.linspace(0, tLen-1, tLen)
close = [data["Adj Close"][i] for i in range(len(data["Adj Close"]))]
DataSeries = [time, close]
print(tLen)
data.tail()

# matrix helpers
def _yi():
    return [np.log(p) for p in DataSeries[1]]

def _fi(tc, m):
    return [np.power((tc - t), m) for t in DataSeries[0]]

def _gi(tc, m, w):
    return [np.power((tc - t), m) * np.cos(w * np.log(tc - t)) for t in DataSeries[0]]

def _hi(tc, m, w):
    return [np.power((tc - t), m) * np.sin(w * np.log(tc - t)) for t in DataSeries[0]]

def _fi_pow_2(tc, m):
    return np.power(_fi(tc, m), 2)

def _gi_pow_2(tc, m, w):
    return np.power(_gi(tc, m, w), 2)

def _hi_pow_2(tc, m, w):
    return np.power(_hi(tc, m, w), 2)

def _figi(tc, m, w):
    return np.multiply(_fi(tc, m), _gi(tc, m, w))

def _fihi(tc, m, w):
    return np.multiply(_fi(tc, m), _hi(tc, m, w))

def _gihi(tc, m, w):
    return np.multiply(_gi(tc, m, w), _hi(tc, m, w))

def _yifi(tc, m):
    return np.multiply(_yi(), _fi(tc, m))

def _yigi(tc, m, w):
    return np.multiply(_yi(), _gi(tc, m, w))

def _yihi(tc, m, w):
    return np.multiply(_yi(), _hi(tc, m, w))

# revised version of the LPPL without φ
# found on page 11 as equation (13)
def lppl(t, tc, m, w, a, b, c1, c2):
    return a + np.power(tc - t, m) * (b + ((c1 * np.cos(w * np.log(tc - t))) + (c2 * np.sin(w * np.log(tc - t)))))


# The distance to the critical time is τ = tc − t for bubbles and τ = t − tc for antibubbles.
def lppl_antibubble(t, tc, m, w, a, b, c1, c2):
    return a + np.power(t - tc, m) * (b + ((c1 * np.cos(w * np.log(t - tc))) + (c2 * np.sin(w * np.log(t - tc)))))


# finds the least square difference
# def func_restricted(x, *args):
def func_restricted(x):
    tc = x[0]
    m  = x[1]
    w  = x[2]
    
    lin_vals = matrix_equation(tc, m, w)
    
    a  = lin_vals[0] 
    b  = lin_vals[1]
    c1 = lin_vals[2] 
    c2 = lin_vals[3]
    
    delta = [lppl(t, tc, m, w, a, b, c1, c2) for t in DataSeries[0]]
    delta = np.subtract(delta, DataSeries[1])
    delta = np.power(delta, 2)
    return np.sum(delta)

# solve the matrix equation
def matrix_equation(tc, m, w):
    N  = tLen
    fi = np.sum(_fi(tc, m))
    gi = np.sum(_gi(tc, m, w))
    hi = np.sum(_hi(tc, m, w))
    fi_pow_2 = np.sum(_fi_pow_2(tc, m))
    gi_pow_2 = np.sum(_gi_pow_2(tc, m, w))
    hi_pow_2= np.sum(_hi_pow_2(tc, m, w))
    figi = np.sum(_figi(tc, m, w))
    fihi = np.sum(_fihi(tc, m, w))
    gihi = np.sum(_gihi(tc, m, w))
    
    yi = np.sum(_yi())
    yifi = np.sum(_yifi(tc, m))
    yigi = np.sum(_yigi(tc, m, w))
    yihi = np.sum(_yihi(tc, m, w))
    
    matrix_1 = np.matrix([
        [N,  fi,       gi,       hi      ],
        [fi, fi_pow_2, figi,     fihi    ],
        [gi, figi,     gi_pow_2, gihi    ],
        [hi, fihi,     gihi,     hi_pow_2]
    ])
    
    matrix_2 = np.matrix([
        [yi],
        [yifi],
        [yigi],
        [yihi]
    ])
    
    product = np.linalg.solve(matrix_1, matrix_2)
    
    return [i[0] for i in product.tolist()]

found_solution = False
solution_count = 0
solutions = []

while not found_solution:
    print("Running {}".format(solution_count))
    
    # set limits for non-linear params
    limits = (
        [tLen-(tLen*0.2), tLen+(tLen*0.2)],    # Critical Time + or - .2
        [0.1, 0.9],                            # m : 0.1 ≤ m ≤ 0.9
        [6, 13],                               # ω : 6 ≤ ω ≤ 13     
    )
    
    # randomly choose vals for non-linear params 
    non_lin_vals = [random.uniform(a[0], a[1]) for a in limits]

    tc = non_lin_vals[0]
    m  = non_lin_vals[1] 
    w  = non_lin_vals[2]
    
    # params to pass to scipy.optimize
    seed = [tc, m, w]
    
    try:
        # scipy optimize minimize
        # Minimize a function with variables subject to bounds, using gradient information in a truncated Newton algorithm. 
        # This method wraps a C implementation of the algorithm.
        # cofs = minimize(fun=func, x0=seed, method='Nelder-Mead', options={'maxfev': 3*500})
        # cofs = minimize(fun=func_restricted, x0=seed, args=("a,b,c1,c2"), method='Nelder-Mead')
        cofs = minimize(fun=func_restricted, x0=seed, method='Nelder-Mead')
        
#         # define search space:
#         tc_bounds = (tLen-(tLen*0.2), tLen+(tLen*0.2))
#         m_bounds  = (0, 2)
#         w_bounds  = (1, 50)
        
#         cofs = minimize(fun=func_restricted, x0=seed, method='SLSQP', bounds=(tc_bounds, m_bounds, w_bounds))
        
        if cofs.success:
            print(cofs)
            solutions.append({
                'fit': func_restricted(cofs.x),
                'cof': cofs.x
            })
            found_solution = True
        else:
            solution_count = solution_count + 1

        print("Success: {}\nMessage: {}".format(cofs.success, cofs.message))
        print("Number of iterations: {}".format(cofs.nit))
        print("Number of evaluations of obj funcs: {}".format(cofs.nfev))
        print("-"*25)
    except Exception as e:
        print("Exception: {}".format(e))
        print(non_lin_vals)
        print(matrix_equation(non_lin_vals[0], non_lin_vals[1], non_lin_vals[2]))
        solution_count = solution_count + 1

for i in solutions:
    tc = i["cof"][0]
    m =  i["cof"][1]
    w =  i["cof"][2]
    
    lin_vals = matrix_equation(tc, m, w)
    
    a  = lin_vals[0] 
    b  = lin_vals[1]
    c1 = lin_vals[2] 
    c2 = lin_vals[3]
    lppl_fit = [lppl(t, tc, m, w, a, b, c1, c2) for t in DataSeries[0]]
    price_data = DataSeries[1]
    
    data = pd.DataFrame({
        'Date': DataSeries[0],
        'LPPL Fit': lppl_fit,
        'S&P500': np.log(price_data),
    })
    data = data.set_index('Date')
    data.plot(figsize=(14,8))